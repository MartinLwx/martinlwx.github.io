<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Programming-Languages - 标签 - MartinLwx&#39;s Blog</title>
        <link>https://martinlwx.github.io/zh-cn/tags/programming-languages/</link>
        <description>Programming-Languages - 标签 - MartinLwx&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>martinlwx@163.com (MartinLwx)</managingEditor>
            <webMaster>martinlwx@163.com (MartinLwx)</webMaster><copyright>&lt;a rel=&#34;license noopener&#34; href=&#34;https://creativecommons.org/licenses/by-nc-nd/4.0/&#34; target=&#34;_blank&#34;&gt;CC BY-NC-ND 4.0&lt;/a&gt;</copyright><lastBuildDate>Sun, 01 Jun 2025 22:50:47 &#43;0800</lastBuildDate><atom:link href="https://martinlwx.github.io/zh-cn/tags/programming-languages/" rel="self" type="application/rss+xml" /><item>
    <title>范畴论与编程：Functor 是什么</title>
    <link>https://martinlwx.github.io/zh-cn/why-functor/</link>
    <pubDate>Sun, 01 Jun 2025 22:50:47 &#43;0800</pubDate><author>
        <name>MartinLwx</name>
    </author><guid>https://martinlwx.github.io/zh-cn/why-functor/</guid>
    <description><![CDATA[<h2 id="引言" class="headerLink">
    <a href="#%e5%bc%95%e8%a8%80" class="header-mark"></a>引言</h2><p>你可能每天都在使用 Functor 但你并没有意识到这一点：当你每次使用各种容器类型的 <code>map</code> 方法的时候，其实就是在利用 Functor 的性质</p>
<p>本篇文章会分别从范畴论的视角、编程语言视角讲解 Functor，希望能对你有所帮助 :)</p>]]></description>
</item><item>
    <title>尾调用与尾调用优化</title>
    <link>https://martinlwx.github.io/zh-cn/tail-call-and-tail-call-optimization/</link>
    <pubDate>Fri, 22 Mar 2024 12:13:53 &#43;0800</pubDate><author>
        <name>MartinLwx</name>
    </author><guid>https://martinlwx.github.io/zh-cn/tail-call-and-tail-call-optimization/</guid>
    <description><![CDATA[<h2 id="尾调用--尾递归" class="headerLink">
    <a href="#%e5%b0%be%e8%b0%83%e7%94%a8--%e5%b0%be%e9%80%92%e5%bd%92" class="header-mark"></a>尾调用 &amp; 尾递归</h2><p>假设函数 <code>A</code> 调用了函数 <code>B</code>，我们称函数 <code>A</code> 为 <em>Caller</em>，函数 <code>B</code> 为 <em>Callee</em>。</p>
<p>尾调用（Tail-call）指的是：Caller <em>最后只需要</em>返回 Callee 这个函数调用的计算结果，其他运算<em>都</em>执行完成了<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>]]></description>
</item></channel>
</rss>
