<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Data-Structure - 标签 - MartinLwx&#39;s Blog</title>
        <link>https://martinlwx.github.io/zh-cn/tags/data-structure/</link>
        <description>Data-Structure - 标签 - MartinLwx&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>martinlwx@163.com (MartinLwx)</managingEditor>
            <webMaster>martinlwx@163.com (MartinLwx)</webMaster><copyright>&lt;a rel=&#34;license noopener&#34; href=&#34;https://creativecommons.org/licenses/by-nc-nd/4.0/&#34; target=&#34;_blank&#34;&gt;CC BY-NC-ND 4.0&lt;/a&gt;</copyright><lastBuildDate>Sun, 11 Jan 2026 22:23:22 &#43;0800</lastBuildDate><atom:link href="https://martinlwx.github.io/zh-cn/tags/data-structure/" rel="self" type="application/rss+xml" /><item>
    <title>后缀数组：快速查找模式串的所有出现位置</title>
    <link>https://martinlwx.github.io/zh-cn/suffix-array-tutorial/</link>
    <pubDate>Sun, 11 Jan 2026 22:23:22 &#43;0800</pubDate><author>
        <name>MartinLwx</name>
    </author><guid>https://martinlwx.github.io/zh-cn/suffix-array-tutorial/</guid>
    <description><![CDATA[<h2 id="后缀数组" class="headerLink">
    <a href="#%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84" class="header-mark"></a>后缀数组</h2><p>从定义上来说，后缀数组（用 <code>sa</code> 表示）包含了字符串 <code>s</code> 所有后缀的起始索引，它是一个 <code>int</code> 数组，<code>sa[i]</code> 表示对应后缀的起始索引。注意后缀已经按照字典序排好。</p>
<p>以字符串 <code>fizzbuzz</code> 为例，它的后缀数组是 <code>4 0 1 5 7 3 6 2</code>，对应关系如下</p>]]></description>
</item><item>
    <title>前缀和数组: 快速计算数组区间和</title>
    <link>https://martinlwx.github.io/zh-cn/ds-prefixsum-array/</link>
    <pubDate>Sat, 15 Mar 2025 19:11:43 &#43;0800</pubDate><author>
        <name>MartinLwx</name>
    </author><guid>https://martinlwx.github.io/zh-cn/ds-prefixsum-array/</guid>
    <description><![CDATA[<h2 id="motivations" class="headerLink">
    <a href="#motivations" class="header-mark"></a>Motivations</h2><p>有这么一类问题——给定一个数组 $arr$ 和 $Q$ 个查询，每一个查询的格式是 $query(l, r)$，意思是计算区间和 $arr[l] + arr[l + 1] + &hellip; + arr[r]$</p>
<p>如果采用暴力求解，那么查询区间和的时间复杂度是 $O(N)$，处理 $Q$ 个查询就需要 $O(NQ)$，<em>有没有</em>什么数据结构或者是算法可以优化这个时间复杂度呢？</p>]]></description>
</item><item>
    <title>如何记忆红黑树的操作</title>
    <link>https://martinlwx.github.io/zh-cn/how-to-memorize-insertion-and-deletion-in-rb-tree/</link>
    <pubDate>Sat, 01 Jul 2023 17:12:40 &#43;0800</pubDate><author>
        <name>MartinLwx</name>
    </author><guid>https://martinlwx.github.io/zh-cn/how-to-memorize-insertion-and-deletion-in-rb-tree/</guid>
    <description><![CDATA[<h2 id="引言" class="headerLink">
    <a href="#%e5%bc%95%e8%a8%80" class="header-mark"></a>引言</h2><p>如果你点进了这一篇文章，相信你也跟我一样：红黑树<strong>学一次忘一次</strong>，又要做树的旋转，又要给节点重新上色，导致每次都是学完了就忘记。我也曾经仔细阅读过 CLRS 写的《算法导论》，但是上面的分类讨论只是让我更加头疼</p>
<p><strong>当然，记住一项东西的最佳方式永远都是理解它</strong>，而最近看到斯坦福的 CS166 高级数据结构课程的<a href="http://web.stanford.edu/class/cs166/lectures/03/Slides03.pdf" target="_blank" rel="noopener noreferrer">课件</a>的时候，我似乎理解了红黑树————<strong>红黑树和 2-3-4 树是等同（isometry）的数据结构，他们只是用了不同的方式表示 2-3-4 树</strong><sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>，这意味着我们<strong>可以通过 2-3-4 树上的节点变化，进而推导出红黑树上的形状和颜色的变化</strong>，而 2-3-4 树的节点变化，是简单很多的</p>]]></description>
</item></channel>
</rss>
