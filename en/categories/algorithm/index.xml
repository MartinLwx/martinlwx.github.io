<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Algorithm - Category - MartinLwx&#39;s Blog</title>
        <link>https://martinlwx.github.io/en/categories/algorithm/</link>
        <description>Algorithm - Category - MartinLwx&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>martinlwx@163.com (MartinLwx)</managingEditor>
            <webMaster>martinlwx@163.com (MartinLwx)</webMaster><copyright>&lt;a rel=&#34;license noopener&#34; href=&#34;https://creativecommons.org/licenses/by-nc-nd/4.0/&#34; target=&#34;_blank&#34;&gt;CC BY-NC-ND 4.0&lt;/a&gt;</copyright><lastBuildDate>Sun, 11 Jan 2026 22:23:22 &#43;0800</lastBuildDate><atom:link href="https://martinlwx.github.io/en/categories/algorithm/" rel="self" type="application/rss+xml" /><item>
    <title>Suffix array: find the needle in the hay</title>
    <link>https://martinlwx.github.io/en/suffix-array-tutorial/</link>
    <pubDate>Sun, 11 Jan 2026 22:23:22 &#43;0800</pubDate><author>
        <name>MartinLwx</name>
    </author><guid>https://martinlwx.github.io/en/suffix-array-tutorial/</guid>
    <description><![CDATA[<h2 id="suffix-array" class="headerLink">
    <a href="#suffix-array" class="header-mark"></a>Suffix array</h2><p>By definition, a suffix array (denoted as <code>sa</code>) contains the starting indices of all suffixes. It&rsquo;s simply an <code>int</code> array where <code>sa[i]</code> represents the starting index of the corresponding suffix.</p>
<p>Taking <code>fizzbuzz</code> as an example, its suffix array is <code>4 0 1 5 7 3 6 2</code>. The details are shown in the following table.</p>
<table>
  <thead>
      <tr>
          <th>Suffix array <code>sa</code></th>
          <th>Corresponding suffix</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>4</td>
          <td><code>buzz</code></td>
      </tr>
      <tr>
          <td>0</td>
          <td><code>fizzbuzz</code></td>
      </tr>
      <tr>
          <td>1</td>
          <td><code>izzbuzz</code></td>
      </tr>
      <tr>
          <td>5</td>
          <td><code>uzz</code></td>
      </tr>
      <tr>
          <td>7</td>
          <td><code>z</code></td>
      </tr>
      <tr>
          <td>3</td>
          <td><code>zbuzz</code></td>
      </tr>
      <tr>
          <td>6</td>
          <td><code>zz</code></td>
      </tr>
      <tr>
          <td>2</td>
          <td><code>zzbuzz</code></td>
      </tr>
  </tbody>
</table>
<h2 id="how-to-generate-a-suffix-array" class="headerLink">
    <a href="#how-to-generate-a-suffix-array" class="header-mark"></a>How to generate a suffix array</h2><h3 id="naive-way" class="headerLink">
    <a href="#naive-way" class="header-mark"></a>Naive way</h3><p>Let $N$ represent the length of the string. The naive algorithm is straightforward: generate all possible suffixes and then sort them using an efficient sorting algorithm. This requires one sort iteration, which may involve $O(N log\ N)$ comparisons. In the worst case, each string comparison takes $O(N)$ time. Therefore, the overall time complexity would be</p>]]></description>
</item><item>
    <title>Kosaraju&#39;s Algorithm Explained</title>
    <link>https://martinlwx.github.io/en/kosaraju-algorithm-explained/</link>
    <pubDate>Sat, 26 Apr 2025 17:23:49 &#43;0800</pubDate><author>
        <name>MartinLwx</name>
    </author><guid>https://martinlwx.github.io/en/kosaraju-algorithm-explained/</guid>
    <description><![CDATA[<h2 id="intro" class="headerLink">
    <a href="#intro" class="header-mark"></a>Intro</h2><p>During my daily coding practice, I encountered an interesting problem - <a href="https://cses.fi/problemset/task/1682/" target="_blank" rel="noopener noreferrer">1682. Flight Routes Check</a>. Solving this problem requires finding all strongly connected components (SCCs) in a directed graph. After some research, I discovered Kosaraju&rsquo;s algorithm, which solves this problem <em>in linear time</em>. That is, the time complexity is</p>
<p>$$
O(V+E)
$$</p>
<p>Where $V$ refers to the nodes and $E$ refers to the edges in the graph.</p>
<p>By interesting, I mean that Kosaraju&rsquo;s algorithm is <em>easy to implement</em> yet <em>a bit tricky to understand fully</em>. In my opinion, knowing why it works matters more than just memorizing how to code it. That&rsquo;s why I&rsquo;m sharing this short post - to break down the key insights.</p>]]></description>
</item><item>
    <title>Prefix Sum Array: the secret to fast range sum query and more</title>
    <link>https://martinlwx.github.io/en/ds-prefixsum-array/</link>
    <pubDate>Sat, 15 Mar 2025 19:11:43 &#43;0800</pubDate><author>
        <name>MartinLwx</name>
    </author><guid>https://martinlwx.github.io/en/ds-prefixsum-array/</guid>
    <description><![CDATA[<h2 id="motivations" class="headerLink">
    <a href="#motivations" class="header-mark"></a>Motivations</h2><p>There is a type of problem where you are given an array $arr$ and $Q$ queries. Each query is represented as $query(l, r)$, which asks for the sum of the elements in the subarray $[l, r]$, i.e., $arr[l] + arr[l + 1] + &hellip; + arr[r]$.</p>
<p>If we handle each query using a brute-force approach, the time complexity will be $O(N)$. Thus, solving $Q$ queries would require $O(NQ)$. Is there a more efficient approach?</p>]]></description>
</item><item>
    <title>The next lexicographical permutation problem</title>
    <link>https://martinlwx.github.io/en/the-next-lexicographical-permutation-problem/</link>
    <pubDate>Wed, 06 Sep 2023 23:13:52 &#43;0800</pubDate><author>
        <name>MartinLwx</name>
    </author><guid>https://martinlwx.github.io/en/the-next-lexicographical-permutation-problem/</guid>
    <description><![CDATA[<h2 id="intro" class="headerLink">
    <a href="#intro" class="header-mark"></a>Intro</h2><p>Occasionally, you may want to <strong>get the next/prev lexicographical permutation of a sequence</strong>. How would you do that? If you are a C++ programmer, you are probably familiar with the <code>next_permutation</code><sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> and <code>prev_permutation</code><sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> APIs. However, Python does not provide the counterparts. So the topic today is how to do this in Python. Since the solutions of prev lexicographical permutation and the next lexicographical permutation are very similar, let us focus on the next lexicographical permutation problem.</p>]]></description>
</item><item>
    <title>Solving DP problems by SRTBOT Framework</title>
    <link>https://martinlwx.github.io/en/solving-dynamic-programming-problems-using-srtbot/</link>
    <pubDate>Sun, 09 Apr 2023 12:30:31 &#43;0800</pubDate><author>
        <name>MartinLwx</name>
    </author><guid>https://martinlwx.github.io/en/solving-dynamic-programming-problems-using-srtbot/</guid>
    <description><![CDATA[<p><strong>Changelog</strong>:</p>
<ul>
<li><a href="#relate-subproblems" rel="">Update dependency graphs</a> @2023.04.13</li>
</ul>
<h2 id="intro" class="headerLink">
    <a href="#intro" class="header-mark"></a>Intro</h2><p>When solving algorithm problems, what often gives me a headache are dynamic programming problems(DP problems). They are the type of problems that I can&rsquo;t figure out on my own after thinking for a long time, but after seeing the answer, it suddenly becomes clear and reasonable. However, the next time I encounter a similar problem, I may forget how to solve it. I have also read many people&rsquo;s solutions and tried to digest and apply their ideas, but <strong>I have been unable to find a particularly good framework that works for all dynamic programming problems</strong>. It seems that everyone has their way of solving dynamic programming problems, and when I try to apply their methods to new problems, I always encounter difficulties. <strong>Things start to change after I learned <a href="https://ocw.mit.edu/courses/6-006-introduction-to-algorithms-spring-2020/" target="_blank" rel="noopener noreferrer">MIT6.006</a></strong>. The teacher presented 6 steps to solve dynamic programming problems, which is called the SRTBOT framework. I found it to be <strong>so useful and practical</strong> that I decided to write this blog post to share it with everyone ðŸ™Œ</p>]]></description>
</item><item>
    <title>Boyer-Moore Majority Voting Algorithm Explained</title>
    <link>https://martinlwx.github.io/en/boyer-moore-majority-voting-algorithm-explained/</link>
    <pubDate>Thu, 24 Mar 2022 18:15:19 &#43;0800</pubDate><author>
        <name>MartinLwx</name>
    </author><guid>https://martinlwx.github.io/en/boyer-moore-majority-voting-algorithm-explained/</guid>
    <description><![CDATA[<h2 id="intro" class="headerLink">
    <a href="#intro" class="header-mark"></a>Intro</h2><hr>
<p>Today I coded the <a href="https://leetcode.com/problems/majority-element/" target="_blank" rel="noopener noreferrer">Leetcode 169. Majority Element</a> again. I vaguely remember what the optimal solution is called Boyer-Moore Majority Voting Algorithm. However, I have no idea what is except for its name. So I plan to systematically learn the principle of this algorithm and summarize it to write this blog. I once heard that:</p>
<blockquote>
  <p>If you want to master something, teach it :)</p>

</blockquote><p>So, I&rsquo;m here today to share this algorithm with you, and try to teach you this method in plain language, so let&rsquo;s get started :)</p>]]></description>
</item></channel>
</rss>
