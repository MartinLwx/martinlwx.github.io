<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Python - Tag - MartinLwx&#39;s blog</title>
        <link>https://martinlwx.github.io/en/tags/python/</link>
        <description>Python - Tag - MartinLwx&#39;s blog</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>martinlwx@163.com (MartinLwx)</managingEditor>
            <webMaster>martinlwx@163.com (MartinLwx)</webMaster><lastBuildDate>Fri, 21 Apr 2023 10:18:16 &#43;0800</lastBuildDate><atom:link href="https://martinlwx.github.io/en/tags/python/" rel="self" type="application/rss+xml" /><item>
    <title>Solution of Proj4. Scheme Interpreter of CS61A (2021-Fall)</title>
    <link>https://martinlwx.github.io/en/proj4-scheme-interpreter-of-cs61a-of-ucb-fa21/</link>
    <pubDate>Fri, 21 Apr 2023 10:18:16 &#43;0800</pubDate>
    <author>MartinLwx</author>
    <guid>https://martinlwx.github.io/en/proj4-scheme-interpreter-of-cs61a-of-ucb-fa21/</guid>
    <description><![CDATA[Intro Recently, I am reading a book called Crafting interpreters written by Robert Nystrom. In the original book, a Tree-walker interpreter jlox was implemented in Java. And I am trying to rewrite in Python - pylox. I highly recommend itðŸ‘. At this moment, I suddenly remembered that there were a few small issues with the Scheme interpreter for CS61A that I had not resolved after finishing it a year ago, which kept it in an unfinished state.]]></description>
</item>
<item>
    <title>Type hints: what and why</title>
    <link>https://martinlwx.github.io/en/type-hints-in-python/</link>
    <pubDate>Fri, 13 Jan 2023 16:18:02 &#43;0800</pubDate>
    <author>MartinLwx</author>
    <guid>https://martinlwx.github.io/en/type-hints-in-python/</guid>
    <description><![CDATA[Intro I was immediately drawn to Python when I first encountered it due to its dynamic language features. Python use the &ldquo;duck typing&rdquo; design, which means that the type of an object is not as important as its behavior. This feature allows for faster development and a reduction in burdensome type declarations. Additionally, the support of powerful third-party libraries solidifies Python as my preferred programming language.ðŸ˜º
However, with the proposal of PEP 4841, Python decided to introduce type hints, which seem to be in line with statically typed languages.]]></description>
</item>
<item>
    <title>Unpacking in Python 3.5</title>
    <link>https://martinlwx.github.io/en/unpacking-in-python/</link>
    <pubDate>Mon, 05 Dec 2022 23:16:30 &#43;0800</pubDate>
    <author>MartinLwx</author>
    <guid>https://martinlwx.github.io/en/unpacking-in-python/</guid>
    <description><![CDATA[This post is originally written in jupyter notebook and then convert to markdown. To get the original notebook files. Please check the repo
Intro Today I want to talk about the unpacking operators(* and **) in python.
Basic usage We use * for numeric data types to indicate we want to do multiplication. However, we can also apply * to iterable objects1, which means we want to unpack all the elements inside them.]]></description>
</item>
<item>
    <title>The f-strings in Python 3.6</title>
    <link>https://martinlwx.github.io/en/f-strings-in-python/</link>
    <pubDate>Wed, 16 Nov 2022 22:15:03 &#43;0800</pubDate>
    <author>MartinLwx</author>
    <guid>https://martinlwx.github.io/en/f-strings-in-python/</guid>
    <description><![CDATA[This post is originally written in jupyter notebook and then convert to markdown. To get the original notebook files. Please check the repo
Intro String formatting can be regarded as one of the most common activities in daily programming. We often need to output various strings and precisely control their format.
In some outdated Python tutorials, you may see the use of % to format strings. However, after Python 3.]]></description>
</item>
<item>
    <title>Walrus Operator in Python 3.8</title>
    <link>https://martinlwx.github.io/en/walrus-operator-in-python/</link>
    <pubDate>Sat, 29 Oct 2022 23:36:12 &#43;0800</pubDate>
    <author>MartinLwx</author>
    <guid>https://martinlwx.github.io/en/walrus-operator-in-python/</guid>
    <description><![CDATA[This post is originally written in jupyter notebook and then convert to markdown. To get the original notebook files. Please check the repo
Intro Today Iâ€™m going to talk about a new feature introduced in Python 3.8: the Walrus operatorï¼ˆ:=ï¼‰, which is a much-debated feature, but itâ€™s finally passed and released ðŸ¤”
In Python, an assignment statement (=) is not an expression but a statement. Walrus operator is expression though.]]></description>
</item>
<item>
    <title>Pattern Matching in Python 3.10</title>
    <link>https://martinlwx.github.io/en/pattern-matching-in-python/</link>
    <pubDate>Sun, 16 Oct 2022 15:14:57 &#43;0800</pubDate>
    <author>MartinLwx</author>
    <guid>https://martinlwx.github.io/en/pattern-matching-in-python/</guid>
    <description><![CDATA[This post is originally written in jupyter notebook and then convert to markdown. To get the original notebook files. Please check the repo
Intro Today I want to talk about the new feature bring in Python 3.10 &ndash; Pattern matching ðŸŽ‰
Those who have learned C language must be familiar with the following switch statement:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 switch (expression) { case constant_1: // statements break; case constant_2: // statements break; // Fall through // the value of the expression can be either constant_3 or constant_4 :) case constant_3: case constant_4: // statements default: // default statements } To recap, the syntax rules of the switch statement:]]></description>
</item>
<item>
    <title>Solution of Proj3.Ants vs SomeBees of CS61A (2021-Fall)</title>
    <link>https://martinlwx.github.io/en/proj3.ants-vs-somebees-of-cs61a-of-ucb/</link>
    <pubDate>Thu, 10 Mar 2022 21:43:59 &#43;0800</pubDate>
    <author>MartinLwx</author>
    <guid>https://martinlwx.github.io/en/proj3.ants-vs-somebees-of-cs61a-of-ucb/</guid>
    <description><![CDATA[Intro I have finished the first two projects - Hog and Cats. The first two projects are relatively simple and uncomplicated. But today, the difficulty of the third project has indeed increased (you can see how complicated this is by looking at the rules of the game). It feels like Plants vs. Zombies
So I&rsquo;m going to write a blog to sort out the ideas when writing code. &#x1f917;
Phase 1: Basic gameplay Problem 1 (1 pt) Part A: Currently, there is no cost for placing any type of Ant, and so there is no challenge to the game.]]></description>
</item>
<item>
    <title>Lab14 - CS61A of UCB(2021-Fall)</title>
    <link>https://martinlwx.github.io/en/lab14-cs61a-of-ucb/</link>
    <pubDate>Thu, 03 Mar 2022 08:17:14 &#43;0800</pubDate>
    <author>MartinLwx</author>
    <guid>https://martinlwx.github.io/en/lab14-cs61a-of-ucb/</guid>
    <description><![CDATA[Trees Q1: Prune Min Write a function that prunes a Tree t mutatively. t and its branches always have zero or two branches. For the trees with two branches, reduce the number of branches from two to one by keeping the branch that has the smaller label value. Do nothing with trees with zero branches.
Prune the tree in a direction of your choosing (top down or bottom up). The result should be a linear tree.]]></description>
</item>
<item>
    <title>Lab12 CS61A of UCB(2021-Fall)</title>
    <link>https://martinlwx.github.io/en/lab12-ca61a-of-ucb/</link>
    <pubDate>Wed, 02 Mar 2022 11:15:08 &#43;0800</pubDate>
    <author>MartinLwx</author>
    <guid>https://martinlwx.github.io/en/lab12-ca61a-of-ucb/</guid>
    <description><![CDATA[Regular Expressions Q1: Calculator Ops Write a regular expression that parses strings written in the 61A Calculator language and returns any expressions which have two numeric operands, leaving out the parentheses around them.
We need to write a regular expression to match a pattern - (operand operator1 operator2). The operands consist of +, -, *, /. We can use [] here. Don&rsquo;t forget to put a \ in front of - to escape it.]]></description>
</item>
<item>
    <title>Hw09 of CS61A of UCB(2021-Fall)</title>
    <link>https://martinlwx.github.io/en/hw09-of-cs61a-of-ucb/</link>
    <pubDate>Tue, 01 Mar 2022 21:13:22 &#43;0800</pubDate>
    <author>MartinLwx</author>
    <guid>https://martinlwx.github.io/en/hw09-of-cs61a-of-ucb/</guid>
    <description><![CDATA[Q2: Roman Numerals Write a regular expression that finds any string of letters that resemble a Roman numeral and aren&rsquo;t part of another word. A Roman numeral is made up of the letters I, V, X, L, C, D, M and is at least one letter long.
For the purposes of this problem, don&rsquo;t worry about whether or not a Roman numeral is valid. For example, &ldquo;VIIIII&rdquo; is not a Roman numeral, but it is fine if your regex matches it.]]></description>
</item>
</channel>
</rss>
